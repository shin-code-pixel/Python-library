###checker.py

1. input.csv を読み込む（表として扱う）
2. rules_required.csv（必須項目ルール）を読む
3. rules_digits.csv（数字・桁数ルール）を読む
4. ルールに従って１行ずつチェックして、エラーをリストに貯める
5. エラー一覧を errors.csv として出力する

---------------------------------------------------------------------------------------------------------------------------
VBAで言うと：
・input.csv を開いて配列に読み込み
・チェック仕様は別シート（ルール表）に書いておいて
・ループでチェック
・エラーを別シートに一覧で書き出す

これを Excelを開かずに、CSVとテキストだけでやっています。

---------------------------------------------------------------------------------------------------------------------------

Python / Pandas の基本対応表（VBA脳向け）
・DataFrame（pandasの表）＝Excelの「範囲」＋「見出し行」をセットで持った感じ
・pd.read_csv（...)　＝　CSVを読み込み（VBAのFileOpen → Split → 配列化みたいな部分）
・for i,v in enumerate（...）= For i = 0 To ... で１行ずつ回す
・list.append(...) = VBA で Collection.Add / ArrayList.Add
・最後に to_csv（...） = エラー一覧シートをCSVに書き出し

---------------------------------------------------------------------------------------------------------------------------

checker.py を上から分解して説明

1)import
import pandas as pd
・pandas を使う宣言です。
・pd は略称（慣習）で、以後 pd.read_csv()みたいに書けます。
VBAでいう Option Explicit とは違って、「ライブラリを読み込む」行です。

-----------------------------------------------------------------------------------

2)設定（ファイル名）
INPUT_CSV = "input.csv"
OUT_ERRORS = "errors.csv"

RULES_REQUIRED = "rules_required.csv"
RULES_DIGITS = "rules_digits.csv"

ここは「固定の設定値」です。
VBAで言えば、
Const INPUT_CSV As String = "input.csv"
みたいな立ち位置です。

-----------------------------------------------------------------------------------

3)add_error 関数（エラーを１件追加する部品）

def add_error(errors, row_idx, column, message, value):
    errors.append({
        "row": row_idx + 2,
        "column": column,
        "message": message,
        "value": "" if pd.isna(value) else str(value)
    })

何のため？
エラーを追加する処理が何回も出てくるので、まとめています。
VBAなら Sub AddError(...)を作るのと同じです。

引数の意味
・errors:エラー一覧を入れている「箱」（list)
・row_idx:0始まりの行番号（Pythonの列挙は0は基本）
・column:エラー対象の列名
・message:エラー理由（例：必須、数字のみ等）
・value:実際に入っていた値

row_idx + 2 の意味

CSVは通常、
・1行目:ヘッダ（列名）
・2行目:データ1行目

Python の row_idx は 0 始まり（0 = データ１行目）なので、
・CSV上の行番号に合わせるため +2 しています。

VBAでも「ヘッダ分+1」みたいな補正、やりますよね。あれです。

pd.isna(value)

value が NaN（欠損扱い）かどうか判定します。
CSVでも空っぽや欠損は状況で NaN っぽく扱われることがあるので、ここで整えています。

-----------------------------------------------------------------------------------

4)main 関数（本体）

def main():
    df = pd.read_csv(INPUT_CSV, dtype=str)
    df.columns = df.columns.astype(str).str.strip().str.lower()

pd.read_csv(..., dtype=str)が超重要

ここがVBAと大きく違うポイントです。

・Python/pandasは「勝手に型を推測」します。
・例えば 0012 が数値と判断されると 12 になってしまう（先頭ゼロが落ちる）

帳票・コード系の世界では致命傷なので、最初から全部文字列として読むのが安全です。
VBAでいう CStr を強制して読むイメージです。

列名正規化（strip + lower）

CSVのヘッダは、空白混入や ID/id 混在が起きやすいです。
それを全部統一します。

・strip():前後空白を削除
・lower():小文字化

VBAで言えば「ヘッダ文字列をTrimしてLCaseする」処理です。

-----------------------------------------------------------------------------------

5)エラー箱を用意
errors = []

これは「エラー一覧」の入れ物です（list）。
VBAならDim errors As New Collection的な役割です。

この箱に「辞書（dict）」をどんどん追加していきます。

-----------------------------------------------------------------------------------

必須チェック部

6)ルール読み込み

req = pd.read_csv(RULES_REQUIRED, dtype=str)
req_cols = [c.strip().lower() for c in req["column"].tolist()]

rules_required.csv の中身

column
id
name

・ルールは「列名一覧」だけ
・その列が空ならエラー

req["column"]

req は表なので、 "column" 列を取り出しています。
VBAで言う「ルール表のA列」みたいなものです。

tolist()

pandasの列を、普通のPythonリストに変換。

-----------------------------------------------------------------------------------

7)必須チェック実行

for col in req_cols:
    if col not in df.columns:
        errors.append({"row": "", "column": col, "message": "必須列が存在しません", "value": ""})
        continue

    for i, v in enumerate(df[col].tolist()):
        if v is None or str(v).strip() == "" or str(v).strip().lower() == "nan":
            add_error(errors, i, col, "必須（空欄）", v)

まず「列が存在するか」
入力CSVにその列が無ければ、行番号の概念がないので row="" でエラーを１件入れます。
VBAでも「列がない=テンプレ違い」みたいな異常扱いしますよね。

enumerate(...)

(i, v)で、
・i:0始まりの行番号
・v:そのセルの値

VBAなら:

For i = 1 To lastRow
    v = Cells(i, col)
Next

に相当します。

空判定が少し多い理由

CSVは「空欄」が
・空文字
・NaN
・Noneっぽく見えるなど揺れることがあるので、雑に広めに拾っています。

-----------------------------------------------------------------------------------

数字・桁数チェック部

8)ルール読み込み

dig = pd.read_csv(RULES_DIGITS, dtype=str)
for _, r in dig.iterrows():
    col = str(r["column"]).strip().lower()
    min_len = int(r["min_len"])
    max_len = int(r["max_len"])

rules_digits.csv の例：

column,min_len,max_len
id,1,10

・id は数字のみ
・桁数は 1 ～ 10

iterrows()
ルール表を１行ずつ読む方法です。
VBAの「ルール表を上から読んで処理する」感じ。

int(...)

桁数比較するので数値化します。

-----------------------------------------------------------------------------------

9)数字・桁数チェック実行

If col not in df.columns:
    errors.append({"row": "", "column": col, "message": "桁数チェック列が存在しません", "value": ""})
    continue

for i, v in enumerate(df[col].tolist()):
    s = "" if v is None else str(v).strip()
    If s == "" or s.lower() == "nan":
        continue # 空は必須側でやる想定
    If not s.isdigit():
        add_error(errors, i, col, "数字のみではありません", v)
        continue
    If not(min_len <= len(s) <= max_len):
        add_error(errors, i, col, f"桁数範囲外（{min_len}~{max_len}) ", v)

空はスキップしている理由

「空は必須チェックで出す」方針なので、ここでは空は見ません。
同じセルで「必須」「数字のみ」の二重エラーを出したくないからです。

s.isdigit()

文字列が全部数字か判定します。
VBAでいうLike "*[!0-9]*" の逆みたいなことです。

len(s)

桁数です。VBAの Len(s)。

-----------------------------------------------------------------------------------

エラー出力部

10)DataFrame化

out = pd.DataFrame(errors, columns=["row", "column", "message", "value"])

ここは「エラー箱（list of dict）を表にする」行です。

VBAで言うなら「エラー一覧シートの列を決めて書き出す」準備。

-----------------------------------------------------------------------------------

11)CSV保存

out.to_csv(OUT_ERRORS, index=False, encoding="utf-8-sig")

・index = False : 行番号（0,1,2....）みたいな余計な列を出さない
・encoding = "utf-8-sig" : Excelで開いたとき文字化けしにくい

-----------------------------------------------------------------------------------

12)ログ表示(print)

print(f"checked: {INPUT_CSV}")
print(f"error: {len(out)} -> {OUT_ERRORS}")

実行結果の目印です。
VBAでいう Debug.Print / MsgBox の軽い版。

-----------------------------------------------------------------------------------

VBAとの「根本の違い」まとめ（大事）

1)Excelと開かない
・VBA: Excelアプリの中で動く（UIやセルが前提）
・Python: ファイルを読み書きする（Excel無しでも回る）

→　帳票（見た目）はVBAが強い
→　チェック・整形・大量処理はPythonが強い

2)型の扱いが違う
・VBA: セルは基本文字列っぽく扱える（意識薄い）
・pandas: 勝手に数値扱いしがち（危険）

→　だから dtype = str は実務で超重要

3)仕様（ルール）を外に出しやすい
今回みたいに「ルールCSV」を作ると、

・コードを書き換えずにチェック項目を増やせる

これは営業に説明しやすい「汎用ツール感」になります。

-----------------------------------------------------------------------------------

1. dtype = str の意味
1-1. pd.read_csv() は「勝手に型を推測」する

pandas は CSV を読むとき、列の中身を見て

・数字っぽい　→　数値（int/float)
・日付っぽい　→　日付っぽい型
・文字っぽい　→　文字列

...みたいに ** 自動判定（推測）** します。

これはデータ分析だと便利ですが、帳票・コード系では事故の元です。

-----------------------------------------------------------------------------------

1-2. VBAと違うポイント（ここが本質）

VBAはセルの表示や文字列操作が中心なので、実務だと

・「見た目が 0012 なら 0012」
・「住所コードは文字として扱う」

みたいに、割と自然に「文字列として扱う」方向に寄ります。

一方 pandas は "データ" として扱うので、

・0012 は数値の 12 と見なす
・先頭ゼロを落とす（0012 → 12）
・大きい数字を勝手に　1.234E+15 みたいにすることもある

こういう事故が起こり得ます。

-----------------------------------------------------------------------------------

1-3. だから dtype = str を指定する

df = pd.read_csv(INPUT_CSV, dtype = str)

これは「全部の列を文字列として読んでね」という意味です。

何が嬉しい？
・先頭ゼロが落ちない
・桁数チェックが正確
・数字チェックが安定
・"コード"を"コード"として扱える

-----------------------------------------------------------------------------------

1-4. 実務用途（あなたの帳票チェックなら必須）

帳票のID・顧客番号・郵便番号・管理番号みたいなものは、数値ではなく文字です。

・数として計算しない
・桁数が意味を持つ
・先頭ゼロが意味を持つ

だから dtype = str は「帳票向けPython」の基本装備です。

用途まとめ：帳票コードの先頭ゼロ/桁を守るための安全装置です。

-----------------------------------------------------------------------------------

2. 列名正規化（strip/lower) の意味

2-1. CSVのヘッダ（列名）は意外と壊れる

あなたが実際に遭遇した通り、列名はこうなりがちです。

・"id"
・"Id"（大小違い）
・" id"（先頭空白）
・"id "（末尾空白）
・Excelから出すと謎の不可視文字が混ざることもある

-----------------------------------------------------------------------------------

2-2. KeyError: 'id' の正体

KeyError: 'id' はつまり

「id という列名が存在しない」

ではなく

「あなたが思ってる id と、実際の列名が一致してない」

ということが多いです。

例：
・見た目：id
・実体　：" id" だった

これだと df["id"]は失敗します。

-----------------------------------------------------------------------------------

2-3. 正規化のコード

df.columns = df.columns.astype(str).str.strip().str.lower()

これを分解すると：

・astype(str): 念のため文字列にする
・strip(): 前後の空白を消す（VBAの Trim)
・lower(): 小文字にする（VBAの LCase)

結果として、 " Id " みたいなのも全部　"id" に揃います。

-----------------------------------------------------------------------------------

用途まとめ：　「列名の揺れ」で落ちるのを防いで、KeyError を潰すための安全装置です。

-----------------------------------------------------------------------------------

3. ルールCSVを読む流れ（なぜ外に出す？）

3-1. なぜルールを外出しするのか

VBAで帳票チェックを作ると、ありがちな構造は

・コード内に「必須列一覧」や「桁数」をベタ書き
・仕様変更のたびにコード修正
・配布し直し・レビューし直し

になりやすいです。

Pythonで ルールをCSVに出すと

・ルール変更 = CSVを編集するだけ
・コードは基本変えない
・汎用ツールっぽくなる（営業にも説明しやすい）

が成立します。

-----------------------------------------------------------------------------------

3-2.











